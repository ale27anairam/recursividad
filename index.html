<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P√°gina Web - Recursividad</title>
  <style>
    body {
      margin: 0;
      font-family: 'Monaco', Times, serif, sans-serif; /*Tipo de letra*/
      background: url(Imagenes/Fondo1.jpg) no-repeat center center fixed; /* üëà Imagen de fondo */
      background-size: cover;
      color: #0a0a0a;
    }

    /* NAVBAR */
    nav {
      position: fixed;
      top: 0;
      width: 100%; /*Tama√±o de las letras del navegador*/
      background: rgb(9, 9, 9); /* transparente para ver la imagen detr√°s */
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0px;
      z-index: 1000;
    }

    nav a {
      color: #f3f7fa;
      margin: 0 20px;
      text-decoration: none;
      font-weight: bold;
      transition: color 0.5s;
    }
    nav a:hover {
      color: #040404;
    }

    /* HERO SECTION */
    .hero {
      height: 75vh; /*Tama√±o del primer cuadro*/
      display: flex;
      justify-content: center;
      align-items: center; 
      flex-direction: column;
      text-align: center;
      color: rgb(223, 204, 204);
      text-shadow: 2px 2px 6px black; /* Para que el texto resalte */
      padding: 40px;
    }
    .hero h1 {
  font-size: 10em; /*Tama√±o de RECURSIVIDAD*/
  animation: fadeInDown 2s;
  color: #f7f8f8; /* Cambia este valor por el color que quieras */
}


    .hero p {
      font-size: 1.5em;
      margin-top: 25px;
      animation: fadeInUp 2s;
    }

    @keyframes fadeInDown {
      from { opacity: 0; transform: translateY(-50px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(50px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* SECCIONES */
    section { /* Fondo de la todos los cuadros de fondo*/
      max-width: 1200px;
      margin: 80px auto;
      padding: 50px;    
      background: rgba(44, 42, 42, 0.6); /*  Capa blanca semitransparente */
      border-radius: 10px;
    }
    h2 {
      color: #f3f4f6;
      text-align: center;
      margin-bottom: 30px;
    }

    /* TARJETAS */
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }
    .card {
      background: rgba(246, 243, 243, 0.848);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
      transition: transform 0.3s;
      animation: fadeIn 2s;
    }
    .card:hover {
      transform: scale(1.05);
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* FOOTER */
    footer {
      background: #1e1f1f;
      color: rgba(255, 255, 255, 0.896);
      text-align: center;
      padding: 20px;
      margin-top: 40px;
    }
  </style>
</head>
<body>

  <!-- NAVBAR -->
  <nav>
    <div class="logo"><a href="#inicio" style="color:white; font-size:30px;">Recursividad</a></div>
    <div>
      <a href="#definicion">Definici√≥n</a>
      <a href="#procedimientos">Procedimientos</a>
      <a href="#caracteristicas">Caracter√≠sticas</a>
      <a href="#complejidad">Complejidad</a>
      <a href="#ejemplos">Ejemplos</a>
      <a href="#conclusion">Conclusi√≥n</a>
      <a href="#referencias">Referencias</a>
    </div>
  </nav>

  <!-- HERO SECTION -->
  <section class="hero" id="inicio">
    <h1>Recursividad</h1>
    <p> Es el comportamiento de una funci√≥n que se llama a s√≠ misma. </p>
    <p>  ‚ÄúPara entender la recursividad hay que entender la recursividad" </p>
  </section>

  <!-- Aqu√≠ siguen tus secciones (definici√≥n, procedimientos, etc.) -->
  

<!-- DEFINICI√ìN -->
<section id="definicion">
  <h2>Definici√≥n de Recursividad</h2>
  <div class="cards"> 
    <!-- Cuadro rectangular -->
    <div class="card grande">

      <p>
        La <b>recursividad</b> es una t√©cnica donde un m√©todo se llama a s√≠ 
        mismo para resolver un problema dividi√©ndolo en subproblemas m√°s
        peque√±os. Facilita soluciones claras y concisas, aunque requiere 
        cuidado para evitar errores como llamadas infinitas o desbordamiento 
        de memoria [1].
      </p>
    
   <br> <!-- salto de l√≠nea -->



  <!-- Dos cuadritos abajo -->
    <div class="card">
      <p>
        <b> Directa: </b> el programa o subprograma se llama directamente a s√≠
         mismo. Representa un programa y en alguna parte y en alguna parte de
        el aparece una llamada a s√≠ mismo [2].</p> 

        Ocurre cuando una funci√≥n se llama a s√≠ misma directamente para 
        resolver un problema.
        <br>
        <p> <b> Ejemplo pr√°ctico: </b>Calcular la suma de los primeros n n√∫meros naturales.</p>
        <img src="Imagenes/Directa1.1.png" width="450" style="display: block; margin: auto;">
        
      </p>
    </div>

    <br> <!-- salto de l√≠nea -->
    <br> <!-- salto de l√≠nea -->
    <br> <!-- salto de l√≠nea -->

    <div class="card">
      <p>
        <b> Indirecta: </b>El subprograma llama a otro subprograma, y √©ste, en alg√∫n 
        momento, llama nuevamente al primero [2]. </p>
        Ocurre cuando una funci√≥n llama a otra funci√≥n distinta, que a su vez 
        llama a la funci√≥n original, creando un ciclo de llamadas entre las 
        funciones.
      </p>
      <p> <b> Ejemplo pr√°ctico: </b>Calcular el valor absoluto de un n√∫mero utilizando recursividad indirecta.</p>
      <img src="Imagenes/Indirecta1.1.png" width="450"style="display: block; margin: auto;">
    </div>
  </div>
</section>


<!-- PROCEDIMIENTOS -->
<section id="Procedimientos">
  <h2>Procedimientos Recursivos y Aplicaciones</h2>
  <div class="cards">
    <div class="card">
      

      <p>Un procedimiento recursivo es aquel que se llama a s√≠ mismo para resolver un problema, generalmente dividi√©ndolo en subproblemas m√°s simples hasta alcanzar un caso base.</p>
      <ul>
        <li>Debe tener un caso base que detenga la recursi√≥n.</li>
        <li>Puede ser directa o indirecta.</li>
        <li>Puede ser lineal, m√∫ltiple o final.</li>
        <li>Permite reemplazar bucles en ciertos problemas complejos de manera m√°s clara.</li>
      </ul>

      <p><b>Aplicaciones comunes:</b></p>
      <p> La recursividad se utiliza en muchos campos de la programaci√≥n y algoritmos por su capacidad de simplificar problemas complejos. Algunos ejemplos comunes:  </p>
      <ul>
        <li><b>Listas enlazadas: </b> recorrer o buscar nodos</li>
        <li> <b> √Årboles y grafos: </b> recorrido en preorden, inorden, posorden.</li>
        <li><b>Pilas y colas: </b> procesos recursivos de inserci√≥n o elimicaci√≥n.  </li>
        
      </ul>
    </div>
  </div>
</section>



  <!-- CARACTER√çSTICAS -->
  <section id="caracteristicas">
    <h2>Caracter√≠sticas de la Recursividad</h2>
    <div class="cards">
      <div class="card">
        <ul>
          <li> Toda funci√≥n recursiva debe tener un caso base que detenga la recursi√≥n y evite llamadas infinitas.
             Ejemplo: if (n == 0) return 1; en factorial. </li>
          <li>Divide un problema en subproblemas m√°s peque√±os.</li>
          <li>Utiliza la pila de llamadas para almacenar estados intermedios.</li>
          <li>Permite soluciones elegantes y compactas.</li>
          <li>Puede ser menos eficiente que soluciones iterativas debido al uso de memoria.</li>
          <li> Permite expresar soluciones claras y concisas frente a problemas que ser√≠an complicados. </li>
          <li> Cada llamda recusiva debe simplicar el calculo de alguna manera [3].</li>
          <p></p>
        </ul>
      </div>
    </div>
  </section>

  <!-- COMPLEJIDAD -->
  <section id="complejidad">
    <h2> Complejidad Computacional en los algoritmos recursivos </h2>
    <div class="cards">
      <div class="card">
        <p> La complejidad computacional de los algoritmos recursivos es un 
            aspecto crucial que debe ser considerado al dise√±ar y analizar 
            algoritmos para garantizar su eficiencia y efectividad en la 
            resoluci√≥n de problemas. </p>
       <p> El prop√≥sito principal de la complejidad computacional es el an√°lisis del comportamiento
         de los algoritmos, buscando medir o estimar los recursos, principalmente el tiempo de ejecuci√≥n, 
         que consumir√°n para resolver problemas [6].</p> 
        <p> La complejidad se mide contando operaciones significativas como las aritm√©ticas y de 
          comparaci√≥n, y se representa mediante una funci√≥n matem√°tica que caracteriza el rendimiento 
          del algoritmo, permitiendo predecir su tiempo de ejecuci√≥n para distintas entradas sin necesidad 
          de ejecutarlo. </p>
        <p>La complejidad de algoritmos recursivos depende del n√∫mero de llamadas recursivas y del trabajo en cada llamada. Ejemplos:</p>
        <ul>
          <li><b>Factorial:</b> O(n)</li>
          <li><b>Fibonacci (versi√≥n simple):</b> O(2‚Åø), muy ineficiente.</li>
          <li><b>Fibonacci con memoizaci√≥n:</b> O(n)</li>
          <li><b>Torres de Han√≥i:</b> O(2‚Åø), exponencial.</li>
    

          <p> </p>

        </ul>
      </div>
    </div>
  </section>

  <!-- EJEMPLOS -->
  <section id="ejemplos">
    <h2>Ejemplos de Algoritmos Recursivos</h2>
    <div class="cards">
      <div class="card">

        <h3>Factorial</h3>
         <p> El factorial de un n√∫mero entero positivo n, representado 
          como n!, es el producto de todos los n√∫meros enteros positivos 
          desde 1 hasta n. </p> 
       <p> La funci√≥n 
        recursiva calcula el factorial de un n√∫mero entero no negativo [1]. </p> 
       
        <p><code>Formula: n! = n * (n-1)!</code>, con el caso base <code>0! = 1</code>.</p>
        <img src="Imagenes/Factorial.png" width="230" style="display: block; margin: auto;">
        <br> <!-- salto de l√≠nea -->
        <img src="Imagenes/Facto Ejemplo.jpg" width="230" style="display: block; margin: auto;">
        
       
      </div>
      <div class="card">



        <h3>Fibonacci</h3>
        <p> La funci√≥n recursiva calcula el n-√©simo t√©rmino de la serie de Fibonacci.</p>
        <p><code>F(n) = F(n-1) + F(n-2)</code>, con <code>F(0)=0</code> y <code>F(1)=1</code>.</p>
        <p>Es la secuencia de enteros: </p>
       <p> <code> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 </code> </p> 
       <p>Cada elemnto de esta secuencia es la suma de los dos elemntos precedentes </p>
       <p> <code>(ej. 0+1=1, 1+1=2, 1+2=3, 2+3=5,... )</code></p>
       <p>Si definimos  fib (0)=0, fib (1)=1, y asi sucesivamente, podemos definir la secuencia de Fibonacci por medio de la siguiente definici√≥n recursiva [4]. </p>
      <img src="Imagenes/Figonacci1.jpg" width="230" style="display: block; margin: auto;">
      <p>Ejemplo en c√≥digo:</p>
       <img src ="Imagenes/Factorial.png" width="250"style="display: block; margin: auto;">
      </div>


      <div class="card">
        <h3>Torres de Han√≥i</h3>
        <p> El problema de la Torre de Hanoi consiste en 
          mover n discos de tama√±o diferente desde una barra
          de origen a una barra de destino, utilizando una 
          barra auxiliar, siguiendo las siguientes reglas: </p>
          <li>Solo se puede mover un disco a la vez.</li>
          <li>Un disco nunca puede colocarse encima de otro disco m√°s peque√±o [5].</li>
        <img src="Imagenes/Honai.png" width="250"style="display: block; margin: auto;">
        <p> Problema cl√°sico de mover discos entre torres siguiendo reglas estrictas.</p>
        <img src="Imagenes/Torres_de.png" width="250"style="display: block; margin: auto;">
      </div>


      <div class="card">
        <h3>Fractales</h3>
        <p>La b√∫squeda binaria es un algoritmo eficiente para buscar un elemento espec√≠fico en un arreglo ordenado.</p>
        <img src="Imagenes/Binario.png" width="250"style="display: block; margin: auto;">
        <p>Estructuras autosimilares generadas recursivamente, como el conjunto de Mandelbrot.</p>
        <br> <!-- salto de l√≠nea -->
        <img src="Imagenes/Facto Ejemplo.1jpg.jpg" width="230" style="display: block; margin: auto;">
      </div>
    </div>
  </section>

  <!-- CONCLUSI√ìN -->
  <section id="conclusion">
  <h2>Conclusi√≥n</h2>
  <div class="cards">
    <div class="card grande">
      <p>
         La recursividad constituye un principio esencial en la programaci√≥n 
         y en las matem√°ticas, pues permite resolver problemas complejos 
         mediante la repetici√≥n de pasos m√°s simples. Ejemplos como el 
         factorial, la sucesi√≥n de Fibonacci, las Torres de Han√≥i y los 
         fractales reflejan la versatilidad de esta t√©cnica, capaz de ir 
         desde aplicaciones formativas hasta representaciones visuales de 
         gran complejidad. Sus caracter√≠sticas de simplicidad, elegancia y 
         autorreferencia la convierten en una herramienta valiosa, aunque su 
         uso tambi√©n implica considerar la complejidad computacional que puede
         generar. En s√≠ntesis, la recursividad muestra c√≥mo un mismo enfoque puede
         aplicarse a diversos contextos, brindando soluciones claras y 
         creativas.
      </p>
    </div>
  </div>
</section>

  <!-- REFERENCIAS -->
  <section id="referencias">
  <h2>Referencias IEEE</h2>
  <div class="cards">
    <div class="card grande">
      
        <li>[1] Nivardo, ‚ÄúRecursividad en Java,‚Äù Oregoom.com, Sep. 09, 2024. https://oregoom.com/java/recursividad/#%C2%BFQue_es_la_recursividad_en_Java</li>
        <li>[2] DR, Osvaldo Cair√≥, ‚ÄúEstructuras de Datos,‚Äù Sepiembre 2025, [Online]. Available: https://www.udocz.com/apuntes/1351947/estructuras-de-datos </li>
        <li>[3] L. Byte, ‚ÄúRecursi√≥n (Recursividad) en Programaci√≥n: Gu√≠a Completa ¬ª CodigoNautas,‚Äù CodigoNautas, Apr. 22, 2025. https://codigonautas.com/recursion-recursividad-programacion/</li>
        <li>[4] M. Raghuwanshi, Algoritmos y estructuras de datos . Nagpur: Alpha Sci. Int. Ltd, 2019. </li>
        <li>[5] Estructura de datos en Pascal . Naucalpan de Ju√°rez, Edo de M√©xico: PRETINCE-HALL HISPANOAM.,SA, 1983. </li>
        <li>[6] Prof. Edgar Tista. Complejidad computacional - parte 1. (Apr. 1, 2020). Accessed: Oct. 2, 2025. [Online Video]. Available: https://www.youtube.com/watch?v=UGmFAbEEd0I  </li>
      
    </div>
  </div>
</section>

  
  <footer>
    <p>Recursividad   ||   Segunda Unidad   ||   IC - 302  || estructura de datos </p>
    <p> Mariana Alejandra Garc√≠a Rojas  || Jessica Orta Barrios || Guadalupe Medina Sotelo</p>
  </footer>

</body>
</html>